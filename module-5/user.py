# Create class architecture

class Product:
    def __init__(self, price):
        self.price = price


class User:
    user_id = 1

    def __init__(self, user_name):
        self.user_name = user_name
        self._user_id = AdminUser.user_id
        AdminUser.user_id += 1

    def can_buy(self, product):
        return "can't buy"

    def __str__(self):
        return f"#{self._user_id} {self.user_name}"


class CustomerUser(User):
    def __init__(self, user_name, user_balance):
        super().__init__(user_name)
        self.balance = user_balance

    def can_buy(self, product):
        if product.price < self.balance:
            return "CAN buy"
        else:
            return "can't buy"


class ModeratorUser(User):
    def __init__(self, user_name: str, user_arguments: set):
        super().__init__(user_name)
        self.topics = user_arguments


class AdminUser(User):
    def __init__(self, user_name: str):
        super().__init__(user_name)


def main():
    # Admin users are a kind of users
    tim = AdminUser("tim")
    sheila = AdminUser("sheila")
    # Customers users have a balance, and they can buy products if they have enough balance
    karen = CustomerUser("karen", 100)  # first arg is name, second is balance
    julio = CustomerUser("julio", 25)
    # Moderators users moderates forums on the website (not relevant to current workshop)
    vince = ModeratorUser("vince", {"flowers", "general"})
    kim = ModeratorUser("kim", {"general", "FAQ"})

    # Products can be bought, they just hold a value - see user.can_buy(product)
    product1 = Product(40)  # first arg is price

    users = [tim, sheila, karen, julio, vince, kim]

    for user in users:
        print(str(user) + " - " + user.can_buy(product1))

    # user should have a nice string representation, which include an id (autogenerated, incrementing)
    assert str(sheila) == "#2 sheila" # format is #{id} {name}
    assert str(kim) == "#6 kim"


if __name__ == "__main__":
    main()

